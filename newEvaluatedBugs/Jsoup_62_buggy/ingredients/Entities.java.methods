CharsetEncoder		java.nio.charset.CharsetEncoder	[java.nio.charset.Charset, float, float, byte[]]
CharsetEncoder		java.nio.charset.CharsetEncoder	[java.nio.charset.Charset, float, float]
CharsetEncoder	java.nio.charset.Charset	charset	[]
CharsetEncoder	byte[]	replacement	[]
CharsetEncoder	java.nio.charset.CharsetEncoder	replaceWith	[byte[]]
CharsetEncoder	void	implReplaceWith	[byte[]]
CharsetEncoder	boolean	isLegalReplacement	[byte[]]
CharsetEncoder	java.nio.charset.CodingErrorAction	malformedInputAction	[]
CharsetEncoder	java.nio.charset.CharsetEncoder	onMalformedInput	[java.nio.charset.CodingErrorAction]
CharsetEncoder	void	implOnMalformedInput	[java.nio.charset.CodingErrorAction]
CharsetEncoder	java.nio.charset.CodingErrorAction	unmappableCharacterAction	[]
CharsetEncoder	java.nio.charset.CharsetEncoder	onUnmappableCharacter	[java.nio.charset.CodingErrorAction]
CharsetEncoder	void	implOnUnmappableCharacter	[java.nio.charset.CodingErrorAction]
CharsetEncoder	float	averageBytesPerChar	[]
CharsetEncoder	float	maxBytesPerChar	[]
CharsetEncoder	java.nio.charset.CoderResult	encode	[java.nio.CharBuffer, java.nio.ByteBuffer, boolean]
CharsetEncoder	java.nio.charset.CoderResult	flush	[java.nio.ByteBuffer]
CharsetEncoder	java.nio.charset.CoderResult	implFlush	[java.nio.ByteBuffer]
CharsetEncoder	java.nio.charset.CharsetEncoder	reset	[]
CharsetEncoder	void	implReset	[]
CharsetEncoder	java.nio.charset.CoderResult	encodeLoop	[java.nio.CharBuffer, java.nio.ByteBuffer]
CharsetEncoder	java.nio.ByteBuffer	encode	[java.nio.CharBuffer]
CharsetEncoder	boolean	canEncode	[java.nio.CharBuffer]
CharsetEncoder	boolean	canEncode	[char]
CharsetEncoder	boolean	canEncode	[java.lang.CharSequence]
CharsetEncoder	void	throwIllegalStateException	[int, int]
Matcher		java.util.regex.Matcher	[]
Matcher		java.util.regex.Matcher	[java.util.regex.Pattern, java.lang.CharSequence]
Matcher	java.util.regex.Pattern	pattern	[]
Matcher	java.util.regex.MatchResult	toMatchResult	[]
Matcher	java.util.regex.Matcher	usePattern	[java.util.regex.Pattern]
Matcher	java.util.regex.Matcher	reset	[]
Matcher	java.util.regex.Matcher	reset	[java.lang.CharSequence]
Matcher	int	start	[]
Matcher	int	start	[int]
Matcher	int	start	[java.lang.String]
Matcher	int	end	[]
Matcher	int	end	[int]
Matcher	int	end	[java.lang.String]
Matcher	java.lang.String	group	[]
Matcher	java.lang.String	group	[int]
Matcher	java.lang.String	group	[java.lang.String]
Matcher	int	groupCount	[]
Matcher	boolean	matches	[]
Matcher	boolean	find	[]
Matcher	boolean	find	[int]
Matcher	boolean	lookingAt	[]
Matcher	java.lang.String	quoteReplacement	[java.lang.String]
Matcher	java.util.regex.Matcher	appendReplacement	[java.lang.StringBuffer, java.lang.String]
Matcher	java.lang.StringBuffer	appendTail	[java.lang.StringBuffer]
Matcher	java.lang.String	replaceAll	[java.lang.String]
Matcher	java.lang.String	replaceFirst	[java.lang.String]
Matcher	java.util.regex.Matcher	region	[int, int]
Matcher	int	regionStart	[]
Matcher	int	regionEnd	[]
Matcher	boolean	hasTransparentBounds	[]
Matcher	java.util.regex.Matcher	useTransparentBounds	[boolean]
Matcher	boolean	hasAnchoringBounds	[]
Matcher	java.util.regex.Matcher	useAnchoringBounds	[boolean]
Matcher	java.lang.String	toString	[]
Matcher	boolean	hitEnd	[]
Matcher	boolean	requireEnd	[]
Matcher	boolean	search	[int]
Matcher	boolean	match	[int, int]
Matcher	int	getTextLength	[]
Matcher	java.lang.CharSequence	getSubSequence	[int, int]
Matcher	char	charAt	[int]
Matcher	int	getMatchedGroupIndex	[java.lang.String]
TreeInfo		java.util.regex.Pattern$TreeInfo	[]
TreeInfo	void	reset	[]
BitClass		java.util.regex.Pattern$BitClass	[]
BitClass		java.util.regex.Pattern$BitClass	[boolean[]]
BitClass	java.util.regex.Pattern.BitClass	add	[int, int]
BitClass	boolean	isSatisfiedBy	[int]
Node		java.util.regex.Pattern$Node	[]
Node	boolean	match	[java.util.regex.Matcher, int, java.lang.CharSequence]
Node	boolean	study	[java.util.regex.Pattern$TreeInfo]
LastNode		java.util.regex.Pattern$LastNode	[]
LastNode	boolean	match	[java.util.regex.Matcher, int, java.lang.CharSequence]
Start		java.util.regex.Pattern$Start	[java.util.regex.Pattern$Node]
Start	boolean	match	[java.util.regex.Matcher, int, java.lang.CharSequence]
Start	boolean	study	[java.util.regex.Pattern$TreeInfo]
StartS		java.util.regex.Pattern$StartS	[java.util.regex.Pattern$Node]
StartS	boolean	match	[java.util.regex.Matcher, int, java.lang.CharSequence]
Begin		java.util.regex.Pattern$Begin	[]
Begin	boolean	match	[java.util.regex.Matcher, int, java.lang.CharSequence]
End		java.util.regex.Pattern$End	[]
End	boolean	match	[java.util.regex.Matcher, int, java.lang.CharSequence]
Caret		java.util.regex.Pattern$Caret	[]
Caret	boolean	match	[java.util.regex.Matcher, int, java.lang.CharSequence]
UnixCaret		java.util.regex.Pattern$UnixCaret	[]
UnixCaret	boolean	match	[java.util.regex.Matcher, int, java.lang.CharSequence]
LastMatch		java.util.regex.Pattern$LastMatch	[]
LastMatch	boolean	match	[java.util.regex.Matcher, int, java.lang.CharSequence]
Dollar		java.util.regex.Pattern$Dollar	[boolean]
Dollar	boolean	match	[java.util.regex.Matcher, int, java.lang.CharSequence]
Dollar	boolean	study	[java.util.regex.Pattern$TreeInfo]
UnixDollar		java.util.regex.Pattern$UnixDollar	[boolean]
UnixDollar	boolean	match	[java.util.regex.Matcher, int, java.lang.CharSequence]
UnixDollar	boolean	study	[java.util.regex.Pattern$TreeInfo]
LineEnding		java.util.regex.Pattern$LineEnding	[]
LineEnding	boolean	match	[java.util.regex.Matcher, int, java.lang.CharSequence]
LineEnding	boolean	study	[java.util.regex.Pattern$TreeInfo]
CharProperty		java.util.regex.Pattern$CharProperty	[]
CharProperty	boolean	isSatisfiedBy	[int]
1		java.util.regex.Pattern$CharProperty$1	[]
1	boolean	isSatisfiedBy	[int]
CharProperty	java.util.regex.Pattern.CharProperty	complement	[]
CharProperty	boolean	match	[java.util.regex.Matcher, int, java.lang.CharSequence]
CharProperty	boolean	study	[java.util.regex.Pattern$TreeInfo]
BmpCharProperty		java.util.regex.Pattern$BmpCharProperty	[]
BmpCharProperty	boolean	match	[java.util.regex.Matcher, int, java.lang.CharSequence]
SingleS		java.util.regex.Pattern$SingleS	[int]
SingleS	boolean	isSatisfiedBy	[int]
Single		java.util.regex.Pattern$Single	[int]
Single	boolean	isSatisfiedBy	[int]
SingleI		java.util.regex.Pattern$SingleI	[int, int]
SingleI	boolean	isSatisfiedBy	[int]
SingleU		java.util.regex.Pattern$SingleU	[int]
SingleU	boolean	isSatisfiedBy	[int]
Block		java.util.regex.Pattern$Block	[java.lang.Character$UnicodeBlock]
Block	boolean	isSatisfiedBy	[int]
Script		java.util.regex.Pattern$Script	[java.lang.Character$UnicodeScript]
Script	boolean	isSatisfiedBy	[int]
Category		java.util.regex.Pattern$Category	[int]
Category	boolean	isSatisfiedBy	[int]
Utype		java.util.regex.Pattern$Utype	[java.util.regex.UnicodeProp]
Utype	boolean	isSatisfiedBy	[int]
Ctype		java.util.regex.Pattern$Ctype	[int]
Ctype	boolean	isSatisfiedBy	[int]
VertWS		java.util.regex.Pattern$VertWS	[]
VertWS	boolean	isSatisfiedBy	[int]
HorizWS		java.util.regex.Pattern$HorizWS	[]
HorizWS	boolean	isSatisfiedBy	[int]
SliceNode		java.util.regex.Pattern$SliceNode	[int[]]
SliceNode	boolean	study	[java.util.regex.Pattern$TreeInfo]
Slice		java.util.regex.Pattern$Slice	[int[]]
Slice	boolean	match	[java.util.regex.Matcher, int, java.lang.CharSequence]
SliceI		java.util.regex.Pattern$SliceI	[int[]]
SliceI	boolean	match	[java.util.regex.Matcher, int, java.lang.CharSequence]
SliceU		java.util.regex.Pattern$SliceU	[int[]]
SliceU	boolean	match	[java.util.regex.Matcher, int, java.lang.CharSequence]
SliceS		java.util.regex.Pattern$SliceS	[int[]]
SliceS	boolean	match	[java.util.regex.Matcher, int, java.lang.CharSequence]
SliceIS		java.util.regex.Pattern$SliceIS	[int[]]
SliceIS	int	toLower	[int]
SliceIS	boolean	match	[java.util.regex.Matcher, int, java.lang.CharSequence]
SliceUS		java.util.regex.Pattern$SliceUS	[int[]]
SliceUS	int	toLower	[int]
All		java.util.regex.Pattern$All	[]
All	boolean	isSatisfiedBy	[int]
Dot		java.util.regex.Pattern$Dot	[]
Dot	boolean	isSatisfiedBy	[int]
UnixDot		java.util.regex.Pattern$UnixDot	[]
UnixDot	boolean	isSatisfiedBy	[int]
Ques		java.util.regex.Pattern$Ques	[java.util.regex.Pattern$Node, int]
Ques	boolean	match	[java.util.regex.Matcher, int, java.lang.CharSequence]
Ques	boolean	study	[java.util.regex.Pattern$TreeInfo]
Curly		java.util.regex.Pattern$Curly	[java.util.regex.Pattern$Node, int, int, int]
Curly	boolean	match	[java.util.regex.Matcher, int, java.lang.CharSequence]
Curly	boolean	match0	[java.util.regex.Matcher, int, int, java.lang.CharSequence]
Curly	boolean	match1	[java.util.regex.Matcher, int, int, java.lang.CharSequence]
Curly	boolean	match2	[java.util.regex.Matcher, int, int, java.lang.CharSequence]
Curly	boolean	study	[java.util.regex.Pattern$TreeInfo]
GroupCurly		java.util.regex.Pattern$GroupCurly	[java.util.regex.Pattern$Node, int, int, int, int, int, boolean]
GroupCurly	boolean	match	[java.util.regex.Matcher, int, java.lang.CharSequence]
GroupCurly	boolean	match0	[java.util.regex.Matcher, int, int, java.lang.CharSequence]
GroupCurly	boolean	match1	[java.util.regex.Matcher, int, int, java.lang.CharSequence]
GroupCurly	boolean	match2	[java.util.regex.Matcher, int, int, java.lang.CharSequence]
GroupCurly	boolean	study	[java.util.regex.Pattern$TreeInfo]
BranchConn		java.util.regex.Pattern$BranchConn	[]
BranchConn	boolean	match	[java.util.regex.Matcher, int, java.lang.CharSequence]
BranchConn	boolean	study	[java.util.regex.Pattern$TreeInfo]
Branch		java.util.regex.Pattern$Branch	[java.util.regex.Pattern$Node, java.util.regex.Pattern$Node, java.util.regex.Pattern$Node]
Branch	void	add	[java.util.regex.Pattern$Node]
Branch	boolean	match	[java.util.regex.Matcher, int, java.lang.CharSequence]
Branch	boolean	study	[java.util.regex.Pattern$TreeInfo]
GroupHead		java.util.regex.Pattern$GroupHead	[int]
GroupHead	boolean	match	[java.util.regex.Matcher, int, java.lang.CharSequence]
GroupHead	boolean	matchRef	[java.util.regex.Matcher, int, java.lang.CharSequence]
GroupRef		java.util.regex.Pattern$GroupRef	[java.util.regex.Pattern$GroupHead]
GroupRef	boolean	match	[java.util.regex.Matcher, int, java.lang.CharSequence]
GroupRef	boolean	study	[java.util.regex.Pattern$TreeInfo]
GroupTail		java.util.regex.Pattern$GroupTail	[int, int]
GroupTail	boolean	match	[java.util.regex.Matcher, int, java.lang.CharSequence]
Prolog		java.util.regex.Pattern$Prolog	[java.util.regex.Pattern$Loop]
Prolog	boolean	match	[java.util.regex.Matcher, int, java.lang.CharSequence]
Prolog	boolean	study	[java.util.regex.Pattern$TreeInfo]
Loop		java.util.regex.Pattern$Loop	[int, int]
Loop	boolean	match	[java.util.regex.Matcher, int, java.lang.CharSequence]
Loop	boolean	matchInit	[java.util.regex.Matcher, int, java.lang.CharSequence]
Loop	boolean	study	[java.util.regex.Pattern$TreeInfo]
LazyLoop		java.util.regex.Pattern$LazyLoop	[int, int]
LazyLoop	boolean	match	[java.util.regex.Matcher, int, java.lang.CharSequence]
LazyLoop	boolean	matchInit	[java.util.regex.Matcher, int, java.lang.CharSequence]
LazyLoop	boolean	study	[java.util.regex.Pattern$TreeInfo]
BackRef		java.util.regex.Pattern$BackRef	[int]
BackRef	boolean	match	[java.util.regex.Matcher, int, java.lang.CharSequence]
BackRef	boolean	study	[java.util.regex.Pattern$TreeInfo]
CIBackRef		java.util.regex.Pattern$CIBackRef	[int, boolean]
CIBackRef	boolean	match	[java.util.regex.Matcher, int, java.lang.CharSequence]
CIBackRef	boolean	study	[java.util.regex.Pattern$TreeInfo]
First		java.util.regex.Pattern$First	[java.util.regex.Pattern$Node]
First	boolean	match	[java.util.regex.Matcher, int, java.lang.CharSequence]
First	boolean	study	[java.util.regex.Pattern$TreeInfo]
Conditional		java.util.regex.Pattern$Conditional	[java.util.regex.Pattern$Node, java.util.regex.Pattern$Node, java.util.regex.Pattern$Node]
Conditional	boolean	match	[java.util.regex.Matcher, int, java.lang.CharSequence]
Conditional	boolean	study	[java.util.regex.Pattern$TreeInfo]
Pos		java.util.regex.Pattern$Pos	[java.util.regex.Pattern$Node]
Pos	boolean	match	[java.util.regex.Matcher, int, java.lang.CharSequence]
Neg		java.util.regex.Pattern$Neg	[java.util.regex.Pattern$Node]
Neg	boolean	match	[java.util.regex.Matcher, int, java.lang.CharSequence]
Behind		java.util.regex.Pattern$Behind	[java.util.regex.Pattern$Node, int, int]
Behind	boolean	match	[java.util.regex.Matcher, int, java.lang.CharSequence]
BehindS		java.util.regex.Pattern$BehindS	[java.util.regex.Pattern$Node, int, int]
BehindS	boolean	match	[java.util.regex.Matcher, int, java.lang.CharSequence]
NotBehind		java.util.regex.Pattern$NotBehind	[java.util.regex.Pattern$Node, int, int]
NotBehind	boolean	match	[java.util.regex.Matcher, int, java.lang.CharSequence]
NotBehindS		java.util.regex.Pattern$NotBehindS	[java.util.regex.Pattern$Node, int, int]
NotBehindS	boolean	match	[java.util.regex.Matcher, int, java.lang.CharSequence]
Bound		java.util.regex.Pattern$Bound	[int, boolean]
Bound	boolean	isWord	[int]
Bound	int	check	[java.util.regex.Matcher, int, java.lang.CharSequence]
Bound	boolean	match	[java.util.regex.Matcher, int, java.lang.CharSequence]
BnM	java.util.regex.Pattern.Node	optimize	[java.util.regex.Pattern$Node]
BnM		java.util.regex.Pattern$BnM	[int[], int[], int[], java.util.regex.Pattern$Node]
BnM	boolean	match	[java.util.regex.Matcher, int, java.lang.CharSequence]
BnM	boolean	study	[java.util.regex.Pattern$TreeInfo]
BnMS		java.util.regex.Pattern$BnMS	[int[], int[], int[], java.util.regex.Pattern$Node]
BnMS	boolean	match	[java.util.regex.Matcher, int, java.lang.CharSequence]
CharPropertyFactory		java.util.regex.Pattern$CharPropertyNames$CharPropertyFactory	[]
CharPropertyFactory	java.util.regex.Pattern.CharProperty	make	[]
CloneableProperty		java.util.regex.Pattern$CharPropertyNames$CloneableProperty	[]
CloneableProperty	java.util.regex.Pattern.CharPropertyNames.CloneableProperty	clone	[]
1		java.util.regex.Pattern$CharPropertyNames$1	[]
1	java.util.regex.Pattern.CharProperty	make	[]
2		java.util.regex.Pattern$CharPropertyNames$2	[]
2	boolean	isSatisfiedBy	[int]
3		java.util.regex.Pattern$CharPropertyNames$3	[]
3	boolean	isSatisfiedBy	[int]
4		java.util.regex.Pattern$CharPropertyNames$4	[]
4	boolean	isSatisfiedBy	[int]
5		java.util.regex.Pattern$CharPropertyNames$5	[]
5	boolean	isSatisfiedBy	[int]
6		java.util.regex.Pattern$CharPropertyNames$6	[]
6	boolean	isSatisfiedBy	[int]
7		java.util.regex.Pattern$CharPropertyNames$7	[]
7	boolean	isSatisfiedBy	[int]
8		java.util.regex.Pattern$CharPropertyNames$8	[]
8	boolean	isSatisfiedBy	[int]
9		java.util.regex.Pattern$CharPropertyNames$9	[]
9	boolean	isSatisfiedBy	[int]
10		java.util.regex.Pattern$CharPropertyNames$10	[]
10	boolean	isSatisfiedBy	[int]
11		java.util.regex.Pattern$CharPropertyNames$11	[]
11	boolean	isSatisfiedBy	[int]
12		java.util.regex.Pattern$CharPropertyNames$12	[]
12	boolean	isSatisfiedBy	[int]
13		java.util.regex.Pattern$CharPropertyNames$13	[]
13	boolean	isSatisfiedBy	[int]
14		java.util.regex.Pattern$CharPropertyNames$14	[]
14	boolean	isSatisfiedBy	[int]
15		java.util.regex.Pattern$CharPropertyNames$15	[]
15	boolean	isSatisfiedBy	[int]
16		java.util.regex.Pattern$CharPropertyNames$16	[]
16	boolean	isSatisfiedBy	[int]
17		java.util.regex.Pattern$CharPropertyNames$17	[]
17	boolean	isSatisfiedBy	[int]
18		java.util.regex.Pattern$CharPropertyNames$18	[]
18	boolean	isSatisfiedBy	[int]
19		java.util.regex.Pattern$CharPropertyNames$19	[]
19	boolean	isSatisfiedBy	[int]
CharPropertyNames		java.util.regex.Pattern$CharPropertyNames	[]
CharPropertyNames	java.util.regex.Pattern.CharProperty	charPropertyFor	[java.lang.String]
20		java.util.regex.Pattern$CharPropertyNames$20	[]
20	java.util.regex.Pattern.CharProperty	make	[]
CharPropertyNames	void	defCategory	[java.lang.String, int]
21		java.util.regex.Pattern$CharPropertyNames$21	[]
21	java.util.regex.Pattern.CharProperty	make	[]
CharPropertyNames	void	defRange	[java.lang.String, int, int]
22		java.util.regex.Pattern$CharPropertyNames$22	[]
22	java.util.regex.Pattern.CharProperty	make	[]
CharPropertyNames	void	defCtype	[java.lang.String, int]
23		java.util.regex.Pattern$CharPropertyNames$23	[]
23	java.util.regex.Pattern.CharProperty	make	[]
CharPropertyNames	void	defClone	[java.lang.String, java.util.regex.Pattern$CharPropertyNames$CloneableProperty]
1		java.util.regex.Pattern$1	[]
1	boolean	match	[java.util.regex.Matcher, int, java.lang.CharSequence]
Pattern	java.util.regex.Pattern	compile	[java.lang.String]
Pattern	java.util.regex.Pattern	compile	[java.lang.String, int]
Pattern	java.lang.String	pattern	[]
Pattern	java.lang.String	toString	[]
Pattern	java.util.regex.Matcher	matcher	[java.lang.CharSequence]
Pattern	int	flags	[]
Pattern	boolean	matches	[java.lang.String, java.lang.CharSequence]
Pattern	java.lang.String[]	split	[java.lang.CharSequence, int]
Pattern	java.lang.String[]	split	[java.lang.CharSequence]
Pattern	java.lang.String	quote	[java.lang.String]
Pattern	void	readObject	[java.io.ObjectInputStream]
Pattern		java.util.regex.Pattern	[java.lang.String, int]
Pattern	void	normalize	[]
Pattern	int	normalizeCharClass	[java.lang.StringBuilder, int]
Pattern	java.lang.String	produceEquivalentAlternation	[java.lang.String]
Pattern	java.lang.String[]	producePermutations	[java.lang.String]
Pattern	int	getClass	[int]
Pattern	java.lang.String	composeOneStep	[java.lang.String]
Pattern	void	RemoveQEQuoting	[]
Pattern	void	compile	[]
Pattern	java.util.Map<java.lang.String, java.lang.Integer>	namedGroups	[]
Pattern	void	printObjectTree	[java.util.regex.Pattern$Node]
Pattern	boolean	has	[int]
Pattern	void	accept	[int, java.lang.String]
Pattern	void	mark	[int]
Pattern	int	peek	[]
Pattern	int	read	[]
Pattern	int	readEscaped	[]
Pattern	int	next	[]
Pattern	int	nextEscaped	[]
Pattern	int	peekPastWhitespace	[int]
Pattern	int	parsePastWhitespace	[int]
Pattern	int	parsePastLine	[]
Pattern	int	peekPastLine	[]
Pattern	boolean	isLineSeparator	[int]
Pattern	int	skip	[]
Pattern	void	unread	[]
Pattern	java.util.regex.PatternSyntaxException	error	[java.lang.String]
Pattern	boolean	findSupplementary	[int, int]
Pattern	boolean	isSupplementary	[int]
Pattern	java.util.regex.Pattern.Node	expr	[java.util.regex.Pattern$Node]
Pattern	java.util.regex.Pattern.Node	sequence	[java.util.regex.Pattern$Node]
Pattern	java.util.regex.Pattern.Node	atom	[]
Pattern	void	append	[int, int]
Pattern	java.util.regex.Pattern.Node	ref	[int]
Pattern	int	escape	[boolean, boolean, boolean]
Pattern	java.util.regex.Pattern.CharProperty	clazz	[boolean]
Pattern	java.util.regex.Pattern.CharProperty	bitsOrSingle	[java.util.regex.Pattern$BitClass, int]
Pattern	java.util.regex.Pattern.CharProperty	range	[java.util.regex.Pattern$BitClass]
Pattern	java.util.regex.Pattern.CharProperty	family	[boolean, boolean]
Pattern	java.util.regex.Pattern.CharProperty	unicodeScriptPropertyFor	[java.lang.String]
Pattern	java.util.regex.Pattern.CharProperty	unicodeBlockPropertyFor	[java.lang.String]
Pattern	java.util.regex.Pattern.CharProperty	charPropertyNodeFor	[java.lang.String]
Pattern	java.lang.String	groupname	[int]
Pattern	java.util.regex.Pattern.Node	group0	[]
Pattern	java.util.regex.Pattern.Node	createGroup	[boolean]
Pattern	void	addFlag	[]
Pattern	void	subFlag	[]
Pattern	java.util.regex.Pattern.Node	closure	[java.util.regex.Pattern$Node]
Pattern	int	c	[]
Pattern	int	o	[]
Pattern	int	x	[]
Pattern	int	cursor	[]
Pattern	void	setcursor	[int]
Pattern	int	uxxxx	[]
Pattern	int	u	[]
Pattern	int	countChars	[java.lang.CharSequence, int, int]
Pattern	int	countCodePoints	[java.lang.CharSequence]
Pattern	java.util.regex.Pattern.CharProperty	newSingle	[int]
Pattern	java.util.regex.Pattern.Node	newSlice	[int[], int, boolean]
Pattern	boolean	inRange	[int, int, int]
2		java.util.regex.Pattern$2	[]
2	boolean	isSatisfiedBy	[int]
Pattern	java.util.regex.Pattern.CharProperty	rangeFor	[int, int]
3		java.util.regex.Pattern$3	[]
3	boolean	isSatisfiedBy	[int]
4		java.util.regex.Pattern$4	[]
4	boolean	isSatisfiedBy	[int]
Pattern	java.util.regex.Pattern.CharProperty	caseInsensitiveRangeFor	[int, int]
5		java.util.regex.Pattern$5	[]
5	boolean	isSatisfiedBy	[int]
Pattern	java.util.regex.Pattern.CharProperty	union	[java.util.regex.Pattern$CharProperty, java.util.regex.Pattern$CharProperty]
6		java.util.regex.Pattern$6	[]
6	boolean	isSatisfiedBy	[int]
Pattern	java.util.regex.Pattern.CharProperty	intersection	[java.util.regex.Pattern$CharProperty, java.util.regex.Pattern$CharProperty]
7		java.util.regex.Pattern$7	[]
7	boolean	isSatisfiedBy	[int]
Pattern	java.util.regex.Pattern.CharProperty	setDifference	[java.util.regex.Pattern$CharProperty, java.util.regex.Pattern$CharProperty]
Pattern	boolean	hasBaseCharacter	[java.util.regex.Matcher, int, java.lang.CharSequence]
Pattern	java.util.function.Predicate<java.lang.String>	asPredicate	[]
1MatcherIterator		java.util.regex.Pattern$1MatcherIterator	[]
1MatcherIterator	java.lang.String	next	[]
1MatcherIterator	boolean	hasNext	[]
Pattern	java.util.stream.Stream<java.lang.String>	splitAsStream	[java.lang.CharSequence]
Node		java.util.HashMap$Node	[int, K, V, java.util.HashMap$Node]
Node	K	getKey	[]
Node	V	getValue	[]
Node	java.lang.String	toString	[]
Node	int	hashCode	[]
Node	V	setValue	[V]
Node	boolean	equals	[java.lang.Object]
KeySet		java.util.HashMap$KeySet	[]
KeySet	int	size	[]
KeySet	void	clear	[]
KeySet	java.util.Iterator<K>	iterator	[]
KeySet	boolean	contains	[java.lang.Object]
KeySet	boolean	remove	[java.lang.Object]
KeySet	java.util.Spliterator<K>	spliterator	[]
KeySet	void	forEach	[java.util.function.Consumer]
Values		java.util.HashMap$Values	[]
Values	int	size	[]
Values	void	clear	[]
Values	java.util.Iterator<V>	iterator	[]
Values	boolean	contains	[java.lang.Object]
Values	java.util.Spliterator<V>	spliterator	[]
Values	void	forEach	[java.util.function.Consumer]
EntrySet		java.util.HashMap$EntrySet	[]
EntrySet	int	size	[]
EntrySet	void	clear	[]
EntrySet	java.util.Iterator<java.util.Map.Entry<K, V>>	iterator	[]
EntrySet	boolean	contains	[java.lang.Object]
EntrySet	boolean	remove	[java.lang.Object]
EntrySet	java.util.Spliterator<java.util.Map.Entry<K, V>>	spliterator	[]
EntrySet	void	forEach	[java.util.function.Consumer]
HashIterator		java.util.HashMap$HashIterator	[]
HashIterator	boolean	hasNext	[]
HashIterator	java.util.HashMap.Node<K, V>	nextNode	[]
HashIterator	void	remove	[]
KeyIterator		java.util.HashMap$KeyIterator	[]
KeyIterator	K	next	[]
ValueIterator		java.util.HashMap$ValueIterator	[]
ValueIterator	V	next	[]
EntryIterator		java.util.HashMap$EntryIterator	[]
EntryIterator	java.util.Map.Entry<K, V>	next	[]
HashMapSpliterator		java.util.HashMap$HashMapSpliterator	[java.util.HashMap, int, int, int, int]
HashMapSpliterator	int	getFence	[]
HashMapSpliterator	long	estimateSize	[]
KeySpliterator		java.util.HashMap$KeySpliterator	[java.util.HashMap, int, int, int, int]
KeySpliterator	java.util.HashMap.KeySpliterator<K, V>	trySplit	[]
KeySpliterator	void	forEachRemaining	[java.util.function.Consumer]
KeySpliterator	boolean	tryAdvance	[java.util.function.Consumer]
KeySpliterator	int	characteristics	[]
ValueSpliterator		java.util.HashMap$ValueSpliterator	[java.util.HashMap, int, int, int, int]
ValueSpliterator	java.util.HashMap.ValueSpliterator<K, V>	trySplit	[]
ValueSpliterator	void	forEachRemaining	[java.util.function.Consumer]
ValueSpliterator	boolean	tryAdvance	[java.util.function.Consumer]
ValueSpliterator	int	characteristics	[]
EntrySpliterator		java.util.HashMap$EntrySpliterator	[java.util.HashMap, int, int, int, int]
EntrySpliterator	java.util.HashMap.EntrySpliterator<K, V>	trySplit	[]
EntrySpliterator	void	forEachRemaining	[java.util.function.Consumer]
EntrySpliterator	boolean	tryAdvance	[java.util.function.Consumer]
EntrySpliterator	int	characteristics	[]
TreeNode		java.util.HashMap$TreeNode	[int, K, V, java.util.HashMap$Node]
TreeNode	java.util.HashMap.TreeNode<K, V>	root	[]
TreeNode	void	moveRootToFront	[java.util.HashMap$Node[], java.util.HashMap$TreeNode]
TreeNode	java.util.HashMap.TreeNode<K, V>	find	[int, java.lang.Object, java.lang.Class]
TreeNode	java.util.HashMap.TreeNode<K, V>	getTreeNode	[int, java.lang.Object]
TreeNode	int	tieBreakOrder	[java.lang.Object, java.lang.Object]
TreeNode	void	treeify	[java.util.HashMap$Node[]]
TreeNode	java.util.HashMap.Node<K, V>	untreeify	[java.util.HashMap]
TreeNode	java.util.HashMap.TreeNode<K, V>	putTreeVal	[java.util.HashMap, java.util.HashMap$Node[], int, K, V]
TreeNode	void	removeTreeNode	[java.util.HashMap, java.util.HashMap$Node[], boolean]
TreeNode	void	split	[java.util.HashMap, java.util.HashMap$Node[], int, int]
TreeNode	java.util.HashMap.TreeNode<K, V>	rotateLeft	[java.util.HashMap$TreeNode, java.util.HashMap$TreeNode]
TreeNode	java.util.HashMap.TreeNode<K, V>	rotateRight	[java.util.HashMap$TreeNode, java.util.HashMap$TreeNode]
TreeNode	java.util.HashMap.TreeNode<K, V>	balanceInsertion	[java.util.HashMap$TreeNode, java.util.HashMap$TreeNode]
TreeNode	java.util.HashMap.TreeNode<K, V>	balanceDeletion	[java.util.HashMap$TreeNode, java.util.HashMap$TreeNode]
TreeNode	boolean	checkInvariants	[java.util.HashMap$TreeNode]
HashMap	int	hash	[java.lang.Object]
HashMap	java.lang.Class<?>	comparableClassFor	[java.lang.Object]
HashMap	int	compareComparables	[java.lang.Class, java.lang.Object, java.lang.Object]
HashMap	int	tableSizeFor	[int]
HashMap		java.util.HashMap	[int, float]
HashMap		java.util.HashMap	[int]
HashMap		java.util.HashMap	[]
HashMap		java.util.HashMap	[java.util.Map]
HashMap	void	putMapEntries	[java.util.Map, boolean]
HashMap	int	size	[]
HashMap	boolean	isEmpty	[]
HashMap	V	get	[java.lang.Object]
HashMap	java.util.HashMap.Node<K, V>	getNode	[int, java.lang.Object]
HashMap	boolean	containsKey	[java.lang.Object]
HashMap	V	put	[K, V]
HashMap	V	putVal	[int, K, V, boolean, boolean]
HashMap	java.util.HashMap.Node<K, V>[]	resize	[]
HashMap	void	treeifyBin	[java.util.HashMap$Node[], int]
HashMap	void	putAll	[java.util.Map]
HashMap	V	remove	[java.lang.Object]
HashMap	java.util.HashMap.Node<K, V>	removeNode	[int, java.lang.Object, java.lang.Object, boolean, boolean]
HashMap	void	clear	[]
HashMap	boolean	containsValue	[java.lang.Object]
HashMap	java.util.Set<K>	keySet	[]
HashMap	java.util.Collection<V>	values	[]
HashMap	java.util.Set<java.util.Map.Entry<K, V>>	entrySet	[]
HashMap	V	getOrDefault	[java.lang.Object, V]
HashMap	V	putIfAbsent	[K, V]
HashMap	boolean	remove	[java.lang.Object, java.lang.Object]
HashMap	boolean	replace	[K, V, V]
HashMap	V	replace	[K, V]
HashMap	V	computeIfAbsent	[K, java.util.function.Function]
HashMap	V	computeIfPresent	[K, java.util.function.BiFunction]
HashMap	V	compute	[K, java.util.function.BiFunction]
HashMap	V	merge	[K, V, java.util.function.BiFunction]
HashMap	void	forEach	[java.util.function.BiConsumer]
HashMap	void	replaceAll	[java.util.function.BiFunction]
HashMap	java.lang.Object	clone	[]
HashMap	float	loadFactor	[]
HashMap	int	capacity	[]
HashMap	void	writeObject	[java.io.ObjectOutputStream]
HashMap	void	readObject	[java.io.ObjectInputStream]
HashMap	java.util.HashMap.Node<K, V>	newNode	[int, K, V, java.util.HashMap$Node]
HashMap	java.util.HashMap.Node<K, V>	replacementNode	[java.util.HashMap$Node, java.util.HashMap$Node]
HashMap	java.util.HashMap.TreeNode<K, V>	newTreeNode	[int, K, V, java.util.HashMap$Node]
HashMap	java.util.HashMap.TreeNode<K, V>	replacementTreeNode	[java.util.HashMap$Node, java.util.HashMap$Node]
HashMap	void	reinitialize	[]
HashMap	void	afterNodeAccess	[java.util.HashMap$Node]
HashMap	void	afterNodeInsertion	[boolean]
HashMap	void	afterNodeRemoval	[java.util.HashMap$Node]
HashMap	void	internalWriteEntries	[java.io.ObjectOutputStream]
EscapeMode		org.jsoup.nodes.Entities$EscapeMode	[]
Entities		org.jsoup.nodes.Entities	[]
Entities	java.lang.String	escape	[java.lang.String, org.jsoup.nodes.Document$OutputSettings]
Entities	java.lang.String	escape	[java.lang.String, java.nio.charset.CharsetEncoder, org.jsoup.nodes.Entities$EscapeMode]
Entities	java.lang.String	unescape	[java.lang.String]
